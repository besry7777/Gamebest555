<!DOCTYPE html>
<html lang="th">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Checkers Game</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Kanit:wght@400;600;700&display=swap" rel="stylesheet">
  <style>
      .loader-overlay {
        position: fixed; inset: 0; background-color: rgba(15, 23, 42, 0.9); /* slate-900 */
        display: none; justify-content: center; align-items: center; z-index: 9999;
        opacity: 0; transition: opacity 0.3s ease-in-out;
      }
      .loader-overlay.active { display: flex; opacity: 1; }
      .loader {
        border: 8px solid #334155; /* slate-700 */ border-top: 8px solid #22d3ee; /* cyan-400 */ border-radius: 50%;
        width: 60px; height: 60px; animation: spin 1s linear infinite;
      }
      @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

      body { font-family: 'Kanit', sans-serif; -webkit-tap-highlight-color: transparent; touch-action: manipulation; }
      .screen { display: none; }
      .screen.active { display: flex; }
      .input-field { @apply w-full px-4 py-3 mb-4 text-center bg-slate-700 text-white border-2 border-slate-600 rounded-lg focus:outline-none focus:border-cyan-400 transition-colors placeholder-slate-400; }
      .button { @apply w-full max-w-sm px-4 py-3 my-2 text-lg font-bold text-white transition-all duration-150 ease-in-out rounded-lg shadow-lg transform active:scale-95 flex justify-center items-center gap-2; }
      .button:disabled { @apply bg-slate-600 opacity-70 cursor-not-allowed transform-none shadow-none; }
      
      .button-primary { @apply bg-gradient-to-br from-cyan-500 to-blue-500 hover:from-cyan-400 hover:to-blue-400 shadow-cyan-500/50; }
      .button-secondary { @apply bg-gradient-to-br from-slate-500 to-slate-600 hover:from-slate-400 hover:to-slate-500 shadow-slate-500/50; }
      .button-success { @apply bg-gradient-to-br from-emerald-500 to-green-500 hover:from-emerald-400 hover:to-green-400 shadow-emerald-500/50; }
      .button-danger { @apply bg-gradient-to-br from-rose-500 to-red-500 hover:from-rose-400 hover:to-red-400 shadow-rose-500/50; }
      
      #game-board {
        display: grid;
        grid-template-columns: repeat(8, 1fr);
        width: 95vw;
        height: 95vw;
        max-width: 500px;
        max-height: 500px;
        aspect-ratio: 1 / 1;
        position: relative;
        border: 6px solid #4a2c2a;
        background-color: #c5966f;
        border-radius: 8px;
        box-shadow: 0 10px 20px rgba(0,0,0,0.5);
      }
      .cell {
        position: relative; display: flex;
        justify-content: center; align-items: center;
      }
      .cell.dark { background-color: #885f40; cursor: pointer; }
      .cell.light { background-color: #c5966f; }

      .piece {
        width: 85%; height: 85%;
        border-radius: 50%;
        display: flex; justify-content: center; align-items: center;
        transition: transform 0.2s ease, box-shadow 0.2s ease;
        position: relative;
        cursor: pointer;
        box-shadow: inset 0 3px 5px rgba(0,0,0,0.3), 0 4px 6px rgba(0,0,0,0.4);
      }
      .piece.player-x, .piece.player-self { background: radial-gradient(#fff, #ddd); }
      .piece.player-o, .piece.player-opponent { background: radial-gradient(#ff4141, #c43425); }
      
      .piece.king::after {
        content: 'üëë';
        font-size: 55%;
        position: absolute;
        text-shadow: 0 0 5px black;
      }
      .cell.selected .piece {
        transform: scale(1.1);
        box-shadow: 0 0 15px 5px #22d3ee, inset 0 3px 5px rgba(0,0,0,0.3);
      }
      .valid-move::before {
        content: '';
        position: absolute;
        width: 35%; height: 35%;
        background-color: rgba(34, 211, 238, 0.6);
        border-radius: 50%;
        animation: pulse 1.5s infinite;
      }
      @keyframes pulse { 0%, 100% { transform: scale(0.9); opacity: 0.7; } 50% { transform: scale(1.1); opacity: 1; } }
      
      .piece.must-capture {
        animation: force-capture-pulse 1.2s infinite;
      }
      @keyframes force-capture-pulse {
        0% { box-shadow: inset 0 3px 5px rgba(0,0,0,0.3), 0 4px 6px rgba(0,0,0,0.4), 0 0 0 0px rgba(251, 113, 133, 0.7); } /* rose-400 */
        70% { box-shadow: inset 0 3px 5px rgba(0,0,0,0.3), 0 4px 6px rgba(0,0,0,0.4), 0 0 0 12px rgba(251, 113, 133, 0); }
        100% { box-shadow: inset 0 3px 5px rgba(0,0,0,0.3), 0 4px 6px rgba(0,0,0,0.4), 0 0 0 0px rgba(251, 113, 133, 0); }
      }

      /* MODIFIED: Mobile responsive game info */
      #game-info {
        display: grid;
        grid-template-columns: 1fr auto 1fr;
        align-items: center;
        width: 100%;
        padding: 0 4px;
        gap: 4px;
      }
      .player-info {
        display: flex;
        align-items: center;
        gap: 8px;
        padding: 4px;
        border-radius: 8px;
        transition: background-color 0.3s, box-shadow 0.3s;
        border: 1px solid transparent;
        overflow: hidden;
      }
      .player-info.active {
        background-color: #0f172a;
        border-color: #22d3ee;
        box-shadow: 0 0 10px #22d3ee80;
      }
      #player-top-info { justify-content: flex-start; }
      #player-bottom-info { justify-content: flex-end; }

      .player-name {
          font-weight: 600;
          font-size: 0.875rem; /* text-sm */
          white-space: nowrap;
          overflow: hidden;
          text-overflow: ellipsis;
          max-width: 80px; /* Adjust as needed */
      }
      .player-count {
          font-size: 0.875rem; /* text-sm */
          flex-shrink: 0;
      }
       @media (min-width: 420px) {
          .player-name { font-size: 1rem; /* text-base */ max-width: 120px; }
          .player-count { font-size: 1rem; /* text-base */ }
      }

      .info-piece { width: 24px; height: 24px; box-shadow: none; flex-shrink: 0; }
      
      .main-menu-button {
          @apply w-full max-w-sm px-4 py-3 my-3 text-lg font-bold text-white transition-all duration-200 ease-in-out rounded-xl shadow-lg transform active:scale-95 flex items-center gap-4 border-2 border-transparent;
          background-color: rgba(255, 255, 255, 0.05);
          backdrop-filter: blur(5px);
          -webkit-backdrop-filter: blur(5px);
          border-color: rgba(255, 255, 255, 0.1);
      }
      .main-menu-button:hover {
          background-color: rgba(255, 255, 255, 0.15);
          border-color: #22d3ee;
      }
      .main-menu-button .icon {
          @apply w-10 h-10 flex justify-center items-center rounded-lg;
      }
       .main-menu-button .text-content {
          @apply flex flex-col items-start;
      }
      .main-menu-button .title {
          @apply text-xl;
      }
      .main-menu-button .subtitle {
          @apply text-sm text-slate-300;
      }

      .game-over-button {
          @apply w-full max-w-xs px-4 py-3 my-2 text-lg font-bold text-white transition-all duration-200 ease-in-out rounded-xl shadow-lg transform active:scale-95 flex items-center gap-4 border-2 border-transparent;
          background-color: rgba(255, 255, 255, 0.05);
          backdrop-filter: blur(5px);
          border-color: rgba(255, 255, 255, 0.1);
      }
       .game-over-button:hover {
          background-color: rgba(255, 255, 255, 0.15);
          border-color: #22d3ee;
      }
      .game-over-button .icon {
          @apply w-10 h-10 flex justify-center items-center rounded-lg;
      }
      .game-over-button .text-content {
          @apply flex flex-col items-start;
      }
  </style>
</head>
<body class="bg-slate-800 text-gray-100">

  <div id="loading-overlay" class="loader-overlay">
      <div class="loader"></div>
  </div>
 
  <main id="app-container" class="w-full h-screen overflow-hidden">
      <div id="main-menu" class="screen w-full h-full flex-col justify-center items-center p-5 text-center">
          <h1 class="text-6xl font-bold mb-2 text-transparent bg-clip-text bg-gradient-to-r from-cyan-400 to-blue-500">Checkers</h1>
          <h2 class="text-2xl font-semibold mb-4 text-slate-300">‡∏´‡∏°‡∏≤‡∏Å‡∏Æ‡∏≠‡∏™</h2>
           <div class="flex flex-col items-center mb-6">
               <h2 id="welcome-message" class="text-2xl text-slate-200"></h2>
           </div>
          <button id="play-bot-btn" class="main-menu-button">
              <div class="icon bg-cyan-500/80">
                  <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                      <path stroke-linecap="round" stroke-linejoin="round" d="M9 3v2m6-2v2M9 19v2m6-2v2M5 9H3m2 6H3m18-6h-2m2 6h-2M12 6V4m0 16v-2M8 8l1.414-1.414M14.586 14.586L16 16m-2.828-8.414L12 9m-1.414 1.414L9 12m-1.172 2.828L6 16m8.414-2.828L16 12m-2.828-1.414L12 9m1.414 1.414L15 12" />
                  </svg>
              </div>
              <div class="text-content">
                  <span class="title">‡πÄ‡∏•‡πà‡∏ô‡∏Å‡∏±‡∏ö‡∏ö‡∏≠‡∏ó</span>
                  <span class="subtitle">‡∏ó‡πâ‡∏≤‡∏ó‡∏≤‡∏¢‡∏ù‡∏µ‡∏°‡∏∑‡∏≠‡∏Å‡∏±‡∏ö‡∏Ñ‡∏≠‡∏°‡∏û‡∏¥‡∏ß‡πÄ‡∏ï‡∏≠‡∏£‡πå</span>
              </div>
          </button>
          <button id="play-coop-btn" class="main-menu-button">
               <div class="icon bg-emerald-500/80">
                  <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                      <path stroke-linecap="round" stroke-linejoin="round" d="M12 4.354a4 4 0 110 5.292M15 21H3v-1a6 6 0 0112 0v1zm0 0h6v-1a6 6 0 00-9-5.197M15 21v-1a6 6 0 00-5.197-5.977" />
                  </svg>
              </div>
              <div class="text-content">
                  <span class="title">‡πÄ‡∏•‡πà‡∏ô‡∏Å‡∏±‡∏ö‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏ô (Online)</span>
                  <span class="subtitle">‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏´‡πâ‡∏≠‡∏á‡∏´‡∏£‡∏∑‡∏≠‡πÄ‡∏Ç‡πâ‡∏≤‡∏£‡πà‡∏ß‡∏°‡∏Å‡∏±‡∏ö‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏ô</span>
              </div>
          </button>
      </div>

      <div id="coop-menu" class="screen w-full h-full flex-col justify-center items-center p-5">
          <h2 class="text-3xl font-bold mb-8">‡πÄ‡∏•‡πà‡∏ô‡∏Å‡∏±‡∏ö‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏ô</h2>
          <button id="create-room-btn" class="button button-primary">‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏´‡πâ‡∏≠‡∏á</button>
          <input type="text" id="room-code-input" class="input-field max-w-sm" placeholder="‡πÉ‡∏™‡πà‡∏£‡∏´‡∏±‡∏™‡∏´‡πâ‡∏≠‡∏á" style="text-transform: uppercase;">
          <button id="join-room-btn" class="button button-success">‡πÄ‡∏Ç‡πâ‡∏≤‡∏£‡πà‡∏ß‡∏°‡∏´‡πâ‡∏≠‡∏á</button>
          <button id="back-to-main-from-coop-btn" class="button button-secondary">‡∏Å‡∏•‡∏±‡∏ö</button>
      </div>

      <div id="room-lobby" class="screen w-full h-full flex-col justify-center items-center p-5 text-center">
          <h2 class="text-2xl mb-2 text-slate-300">‡∏£‡∏´‡∏±‡∏™‡∏´‡πâ‡∏≠‡∏á:</h2>
           <div class="flex items-center justify-center gap-2 mb-6">
               <span id="room-code-display" class="text-5xl font-bold text-cyan-400 tracking-widest"></span>
           </div>
          <div id="player-list" class="text-xl mb-6 space-y-2 w-full max-w-sm"></div>
          <p id="lobby-status" class="mb-6 h-12 text-2xl flex justify-center items-center"></p>
          <button id="ready-btn" class="button button-success">‡πÄ‡∏ï‡∏£‡∏µ‡∏¢‡∏°‡∏û‡∏£‡πâ‡∏≠‡∏°</button>
          <button id="leave-room-btn" class="button button-danger">‡∏≠‡∏≠‡∏Å‡∏à‡∏≤‡∏Å‡∏´‡πâ‡∏≠‡∏á</button>
      </div>
      
      <div id="game-screen" class="screen w-full h-full flex-col justify-center items-center p-2 sm:p-4 relative">
          
          <div class="flex flex-col items-center w-full max-w-[500px]">
             <!-- MODIFIED: Restructured game info for mobile -->
            <div id="game-info" class="mb-4">
                  <div id="player-top-info" class="player-info">
                      <div class="info-piece"></div>
                      <span id="player-top-name" class="player-name">Opponent</span>
                      <span id="player-top-count" class="player-count">(8)</span>
                  </div>
                  <div class="text-center">
                    <div id="turn-display" class="text-lg sm:text-xl font-bold text-cyan-400">‡∏ï‡∏≤‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏∏‡∏ì</div>
                    <div id="force-capture-notice" class="text-xs sm:text-sm font-semibold text-rose-400 h-5 animate-pulse"></div>
                  </div>
                   <div id="player-bottom-info" class="player-info">
                      <span id="player-bottom-name" class="player-name">You</span>
                      <span id="player-bottom-count" class="player-count">(8)</span>
                      <div class="info-piece"></div>
                   </div>
            </div>

            <div id="game-board-container">
                <div id="game-board"></div>
            </div>
          </div>
          
          <div id="game-screen-over-overlay" class="absolute inset-0 bg-slate-900/80 backdrop-blur-sm flex-col justify-center items-center text-center p-5 hidden">
                <h2 id="game-over-message" class="text-5xl font-bold mb-2"></h2>
                <div id="rematch-status" class="h-6 my-4 text-lg"></div>
                <button id="rematch-btn" class="game-over-button">
                     <div class="icon bg-cyan-500/80">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                           <path stroke-linecap="round" stroke-linejoin="round" d="M4 4v5h5M4 12a8 8 0 108-8" />
                        </svg>
                     </div>
                     <span class="text-content">‡πÄ‡∏•‡πà‡∏ô‡∏≠‡∏µ‡∏Å‡∏Ñ‡∏£‡∏±‡πâ‡∏á</span>
                </button>
                <button id="back-to-menu-from-game-btn" class="game-over-button">
                     <div class="icon bg-slate-500/80">
                         <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                           <path stroke-linecap="round" stroke-linejoin="round" d="M3 12l2-2m0 0l7-7 7 7M5 10v10a1 1 0 001 1h3m10-11l2 2m-2-2v10a1 1 0 01-1 1h-3" />
                         </svg>
                     </div>
                     <span class="text-content">‡∏Å‡∏•‡∏±‡∏ö‡πÄ‡∏°‡∏ô‡∏π‡∏´‡∏•‡∏±‡∏Å</span>
                </button>
          </div>

          <button id="leave-game-btn" class="button button-danger mt-4 max-w-[500px]">‡∏¢‡∏≠‡∏°‡πÅ‡∏û‡πâ/‡∏≠‡∏≠‡∏Å‡∏à‡∏≤‡∏Å‡πÄ‡∏Å‡∏°</button>

          <button id="cheat-icon" class="absolute bottom-4 right-4 text-slate-500 hover:text-cyan-400 transition-colors hidden">
              <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                  <path stroke-linecap="round" stroke-linejoin="round" d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066 2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z" />
                  <path stroke-linecap="round" stroke-linejoin="round" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" />
              </svg>
          </button>

          <div id="cheat-modal" class="absolute inset-0 bg-slate-900/80 backdrop-blur-sm flex-col justify-center items-center text-center p-5 hidden">
              <div class="bg-slate-800 p-8 rounded-lg shadow-xl border border-slate-700 w-full max-w-sm">
                  <h3 class="text-2xl font-bold mb-4 text-cyan-400">‡∏•‡∏±‡∏ö‡πÄ‡∏â‡∏û‡∏≤‡∏∞</h3>
                  <p class="text-slate-300 mb-6">‡∏õ‡πâ‡∏≠‡∏ô‡∏£‡∏´‡∏±‡∏™‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏£‡∏±‡∏ö‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ä‡πà‡∏ß‡∏¢‡πÄ‡∏´‡∏•‡∏∑‡∏≠</p>
                  <input type="number" id="cheat-code-input" class="input-field" placeholder="‡∏£‡∏´‡∏±‡∏™‡∏•‡∏±‡∏ö">
                  <button id="submit-cheat-btn" class="button button-primary">‡∏¢‡∏∑‡∏ô‡∏¢‡∏±‡∏ô</button>
                  <button id="close-cheat-btn" class="button button-secondary mt-2">‡∏¢‡∏Å‡πÄ‡∏•‡∏¥‡∏Å</button>
              </div>
          </div>
      </div>
  </main>
 
  <script type="module">
      import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
      import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
      import { getFirestore, doc, getDoc, setDoc, updateDoc, onSnapshot, runTransaction, serverTimestamp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

      const firebaseConfig = {
          apiKey: "AIzaSyBcxVAP08XMiPMoqElaKM7AYY_2z08oWok",
          authDomain: "xobybestry777.firebaseapp.com",
          projectId: "xobybestry777",
          storageBucket: "xobybestry777.firebasestorage.app",
          messagingSenderId: "380539937989",
          appId: "1:380539937989:web:48049ed77f45327e033cac",
          measurementId: "G-YZWTKXL285"
      };
      const app = initializeApp(firebaseConfig);
      const auth = getAuth(app);
      const db = getFirestore(app);

      const CONST = {
          ROOM_CODE_LENGTH: 4,
          BOARD_SIZE: 8,
          SECRET_CODE: 1337,
      };
      
      let AppState = {
          currentUser: { uid: null, username: null },
          currentRoom: { id: null, data: null },
          playerSymbol: '',
          listeners: { room: null },
          game: { 
              board: [], currentPlayer: "X", isActive: false, mode: 'bot',
              selectedPieceIndex: null, validMoves: {}, mustContinueJump: false,
              isForcedCapture: false,
          },
      };
      
      const DOM = {
          screens: { mainMenu: document.getElementById('main-menu'), coopMenu: document.getElementById('coop-menu'), roomLobby: document.getElementById('room-lobby'), game: document.getElementById('game-screen') },
          gameBoard: document.getElementById('game-board'),
          rematchBtn: document.getElementById('rematch-btn'),
          rematchStatus: document.getElementById('rematch-status'),
          gameOverOverlay: document.getElementById('game-screen-over-overlay'),
          gameOverMessage: document.getElementById('game-over-message'),
          loadingOverlay: document.getElementById('loading-overlay'),
          cheatModal: document.getElementById('cheat-modal'),
      };

      const init = () => {
          DOM.loadingOverlay.classList.add('active');
          addEventListeners();
          onAuthStateChanged(auth, async (user) => {
              if (!user) { await signInAnonymously(auth); return; }
              AppState.currentUser.uid = user.uid;
              const userRef = doc(db, "users", user.uid);
              const userSnap = await getDoc(userRef);
              AppState.currentUser.username = userSnap.exists() ? userSnap.data().username : `Player${Math.floor(1000 + Math.random() * 9000)}`;
              if (!userSnap.exists()) await setDoc(userRef, { username: AppState.currentUser.username });
              
              document.getElementById('welcome-message').innerText = `‡∏¢‡∏¥‡∏ô‡∏î‡∏µ‡∏ï‡πâ‡∏≠‡∏ô‡∏£‡∏±‡∏ö, ${AppState.currentUser.username}`;
              DOM.loadingOverlay.classList.remove('active');
              showScreen('mainMenu');
          });
      };
      
      function createInitialBoard() {
          const board = Array(CONST.BOARD_SIZE * CONST.BOARD_SIZE).fill(null);
          for (let i = 0; i < board.length; i++) {
              const row = Math.floor(i / CONST.BOARD_SIZE), col = i % CONST.BOARD_SIZE;
              if ((row + col) % 2 !== 0) {
                  if (row < 2) board[i] = { player: 'O', isKing: false };
                  if (row > 5) board[i] = { player: 'X', isKing: false };
              }
          }
          return board;
      }
      
      function resetGameUIAndState() {
          AppState.game.isActive = true;
          AppState.game.selectedPieceIndex = null;
          AppState.game.mustContinueJump = false;
          AppState.game.isForcedCapture = false;
          DOM.gameOverOverlay.classList.add('hidden');
          DOM.rematchBtn.disabled = false;
          DOM.rematchStatus.textContent = '';
          document.getElementById('leave-game-btn').style.display = 'flex';
      }

      function startGame() {
          AppState.game.board = createInitialBoard();
          resetGameUIAndState();
          
          const cheatIcon = document.getElementById('cheat-icon');
          if (AppState.game.mode === 'bot') {
              cheatIcon.style.display = 'none';
              AppState.game.currentPlayer = Math.random() < 0.5 ? 'X' : 'O';
              document.getElementById('player-bottom-name').textContent = AppState.currentUser.username;
              document.getElementById('player-top-name').textContent = "‡∏ö‡∏≠‡∏ó";
              document.querySelector('#player-bottom-info .info-piece').className = 'piece player-x info-piece';
              document.querySelector('#player-top-info .info-piece').className = 'piece player-o info-piece';
          } else {
              cheatIcon.style.display = 'block';
              AppState.game.currentPlayer = AppState.currentRoom.data.game.turn;
              const selfPlayer = Object.values(AppState.currentRoom.data.players).find(p => p.symbol === AppState.playerSymbol);
              const opponentPlayer = Object.values(AppState.currentRoom.data.players).find(p => p.symbol !== AppState.playerSymbol);
              document.getElementById('player-bottom-name').textContent = selfPlayer.username;
              document.getElementById('player-top-name').textContent = opponentPlayer.username;
              document.querySelector('#player-bottom-info .info-piece').className = 'piece player-self info-piece';
              document.querySelector('#player-top-info .info-piece').className = 'piece player-opponent info-piece';
          }

          showScreen('game');
          findAllValidMoves();
          renderBoard();

          if (AppState.game.mode === 'bot' && AppState.game.currentPlayer === 'O') {
              setTimeout(botMove, 500);
          }
      }
      
      function renderBoard() {
          const boardEl = DOM.gameBoard;
          boardEl.innerHTML = '';
          let xCount = 0, oCount = 0;
          
          const boardSize = CONST.BOARD_SIZE * CONST.BOARD_SIZE;
          const isFlipped = AppState.game.mode === 'coop' && AppState.playerSymbol === 'O';

          for (let i = 0; i < boardSize; i++) {
              const renderIndex = isFlipped ? (boardSize - 1 - i) : i;

              const piece = AppState.game.board[renderIndex];
              const cell = document.createElement('div');
              const row = Math.floor(renderIndex / CONST.BOARD_SIZE), col = renderIndex % CONST.BOARD_SIZE;
              cell.className = `cell ${(row + col) % 2 === 0 ? 'light' : 'dark'}`;
              cell.dataset.index = renderIndex; 

              if (piece) {
                  piece.player === 'X' ? xCount++ : oCount++;
                  const pieceEl = document.createElement('div');
                  let pieceClass = '';
                  if (AppState.game.mode === 'coop') {
                      pieceClass = piece.player === AppState.playerSymbol ? 'player-self' : 'player-opponent';
                  } else {
                      pieceClass = `player-${piece.player.toLowerCase()}`;
                  }
                  pieceEl.className = `piece ${pieceClass} ${piece.isKing ? 'king' : ''}`;
                  
                  const mustMovePieces = Object.keys(AppState.game.validMoves);
                  if (AppState.game.isForcedCapture && mustMovePieces.includes(renderIndex.toString())) {
                      pieceEl.classList.add('must-capture');
                  }

                  cell.appendChild(pieceEl);
              }

              if (AppState.game.selectedPieceIndex === renderIndex) cell.classList.add('selected');
              
              const movesForSelected = AppState.game.validMoves[AppState.game.selectedPieceIndex] || [];
              if (movesForSelected.some(move => move.to === renderIndex)) {
                  cell.classList.add('valid-move');
              }
              boardEl.appendChild(cell);
          }
          
          if (AppState.game.mode === 'coop') {
              const selfSymbol = AppState.playerSymbol;
              document.getElementById('player-bottom-count').textContent = `(${selfSymbol === 'X' ? xCount : oCount})`;
              document.getElementById('player-top-count').textContent = `(${selfSymbol === 'X' ? oCount : xCount})`;
          } else {
              document.getElementById('player-bottom-count').textContent = `(${xCount})`;
              document.getElementById('player-top-count').textContent = `(${oCount})`;
          }

          updateTurnDisplay();
      }
      
      function updateTurnDisplay() {
          const turnDisplay = document.getElementById('turn-display');
          const forceCaptureNotice = document.getElementById('force-capture-notice');
          const playerBottomInfo = document.getElementById('player-bottom-info');
          const playerTopInfo = document.getElementById('player-top-info');
          let isMyTurn;
          if(AppState.game.mode === 'coop'){
              isMyTurn = AppState.game.currentPlayer === AppState.playerSymbol;
          } else {
              isMyTurn = AppState.game.currentPlayer === 'X';
          }
          playerBottomInfo.classList.toggle('active', isMyTurn && AppState.game.isActive);
          playerTopInfo.classList.toggle('active', !isMyTurn && AppState.game.isActive);
          
          if (!AppState.game.isActive) {
              turnDisplay.textContent = "‡∏à‡∏ö‡πÄ‡∏Å‡∏°";
              forceCaptureNotice.textContent = '';
              return;
          }

          turnDisplay.textContent = isMyTurn ? "‡∏ï‡∏≤‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏∏‡∏ì" : "‡∏ï‡∏≤‡∏ù‡πà‡∏≤‡∏¢‡∏ï‡∏£‡∏á‡∏Ç‡πâ‡∏≤‡∏°";
          forceCaptureNotice.textContent = isMyTurn && AppState.game.isForcedCapture ? '‡∏ö‡∏±‡∏á‡∏Ñ‡∏±‡∏ö‡∏Å‡∏¥‡∏ô' : '';
      }

      function getMovesForPiece(index, board, player) {
          const piece = board[index];
          if (!piece || piece.player !== player) return { moves: [], captures: [] };
          const forwardDir = player === 'X' ? -1 : 1;
          return piece.isKing ? getKingMoves(index, board, player) : getManMoves(index, board, player, forwardDir);
      }

      function getManMoves(index, board, player, forwardDir) {
          const moves = [], captures = [];
          const row = Math.floor(index / 8), col = index % 8;
          for (const dCol of [-1, 1]) {
              const nRow = row + forwardDir, nCol = col + dCol;
              if (nRow >= 0 && nRow < 8 && nCol >= 0 && nCol < 8 && !board[nRow * 8 + nCol]) {
                  moves.push({ to: nRow * 8 + nCol, captures: [] });
              }
          }
          recursivelyFindCaptures(index, board, [], captures, false, player, forwardDir);
          return { moves, captures };
      }
      
      function getKingMoves(index, board, player) {
          const moves = [], captures = [];
          for (const dRow of [-1, 1]) {
              for (const dCol of [-1, 1]) {
                  for (let i = 1; i < 8; i++) {
                      const nRow = Math.floor(index / 8) + dRow * i, nCol = (index % 8) + dCol * i;
                      if (nRow < 0 || nRow >= 8 || nCol < 0 || nCol >= 8) break;
                      const newIndex = nRow * 8 + nCol;
                      if (board[newIndex]) break;
                      moves.push({ to: newIndex, captures: [] });
                  }
              }
          }
          recursivelyFindKingCaptures(index, board, [], captures, player);
          return { moves, captures };
      }

      function recursivelyFindCaptures(startIndex, currentBoard, capturedSoFar, finalPaths, isContinuingJump, player, forwardDir) {
          let canContinue = false;
          const opponent = player === 'X' ? 'O' : 'X';
          for (const dRow of [forwardDir]) {
              for (const dCol of [-1, 1]) {
                  const row = Math.floor(startIndex / 8), col = startIndex % 8;
                  const viaRow = row + dRow, viaCol = col + dCol;
                  const toRow = row + 2 * dRow, toCol = col + 2 * dCol;
                  if (toRow >= 0 && toRow < 8 && toCol >= 0 && toCol < 8) {
                      const viaIndex = viaRow * 8 + viaCol, toIndex = toRow * 8 + toCol;
                      if (currentBoard[viaIndex]?.player === opponent && !currentBoard[toIndex] && !capturedSoFar.includes(viaIndex)) {
                          canContinue = true;
                          const nextBoard = [...currentBoard];
                          nextBoard[toIndex] = nextBoard[startIndex]; nextBoard[startIndex] = null; nextBoard[viaIndex] = null;
                          recursivelyFindCaptures(toIndex, nextBoard, [...capturedSoFar, viaIndex], finalPaths, true, player, forwardDir);
                      }
                  }
              }
          }
          if (!canContinue && capturedSoFar.length > 0) {
              finalPaths.push({ to: startIndex, captures: capturedSoFar });
          }
      }

      function recursivelyFindKingCaptures(startIndex, currentBoard, capturedSoFar, finalPaths, player) {
          let canContinue = false;
          const opponent = player === 'X' ? 'O' : 'X';
          for (const dRow of [-1, 1]) {
              for (const dCol of [-1, 1]) {
                  for (let i = 1; i < CONST.BOARD_SIZE; i++) {
                      const checkRow = Math.floor(startIndex / CONST.BOARD_SIZE) + i * dRow;
                      const checkCol = (startIndex % CONST.BOARD_SIZE) + i * dCol;
                      if (checkRow < 0 || checkRow >= CONST.BOARD_SIZE || checkCol < 0 || checkCol >= CONST.BOARD_SIZE) { break; }
                      const checkIndex = checkRow * CONST.BOARD_SIZE + checkCol;
                      const piece = currentBoard[checkIndex];
                      if (piece) {
                          if (piece.player === opponent && !capturedSoFar.includes(checkIndex)) {
                              const landingRow = checkRow + dRow;
                              const landingCol = checkCol + dCol;
                              if (landingRow >= 0 && landingRow < CONST.BOARD_SIZE && landingCol >= 0 && landingCol < CONST.BOARD_SIZE) {
                                  const landingIndex = landingRow * CONST.BOARD_SIZE + landingCol;
                                  if (!currentBoard[landingIndex]) {
                                      canContinue = true;
                                      const nextBoard = [...currentBoard];
                                      nextBoard[landingIndex] = nextBoard[startIndex];
                                      nextBoard[startIndex] = null;
                                      nextBoard[checkIndex] = null;
                                      recursivelyFindKingCaptures(landingIndex, nextBoard, [...capturedSoFar, checkIndex], finalPaths, player);
                                  }
                              }
                          }
                          break;
                      }
                  }
              }
          }
          if (!canContinue && capturedSoFar.length > 0) {
              finalPaths.push({ to: startIndex, captures: capturedSoFar });
          }
      }

      function findAllValidMoves() {
          const { currentPlayer, board } = AppState.game;
          AppState.game.isForcedCapture = false;
          let allCaptures = {}, maxCaptureLength = 0;
          for (let i = 0; i < board.length; i++) {
              if (board[i]?.player === currentPlayer) {
                  const { captures } = getMovesForPiece(i, board, currentPlayer);
                  if (captures.length > 0) {
                      allCaptures[i] = captures;
                      captures.forEach(c => maxCaptureLength = Math.max(maxCaptureLength, c.captures.length));
                  }
              }
          }
          if (maxCaptureLength > 0) {
              AppState.game.isForcedCapture = true;
              const bestCaptures = {};
              for (const fromIndex in allCaptures) {
                  const filtered = allCaptures[fromIndex].filter(c => c.captures.length === maxCaptureLength);
                  if (filtered.length > 0) bestCaptures[fromIndex] = filtered;
              }
              AppState.game.validMoves = bestCaptures; 
              return;
          }
          const allMoves = {};
          for (let i = 0; i < board.length; i++) {
              if (board[i]?.player === currentPlayer) {
                  const { moves } = getMovesForPiece(i, board, currentPlayer);
                  if (moves.length > 0) allMoves[i] = moves;
              }
          }
          AppState.game.validMoves = allMoves;
      }
      
      function handleCellClick(index) {
          if (!AppState.game.isActive || (AppState.game.mode === 'coop' && AppState.playerSymbol !== AppState.game.currentPlayer)) return;
          if (AppState.game.mustContinueJump) {
              const movesForSelected = AppState.game.validMoves[AppState.game.selectedPieceIndex] || [];
              if (movesForSelected.some(move => move.to === index)) makeMove(AppState.game.selectedPieceIndex, index);
              return;
          }
          const piece = AppState.game.board[index];
          if (piece?.player === AppState.game.currentPlayer && AppState.game.validMoves[index]) {
              AppState.game.selectedPieceIndex = index;
              renderBoard();
          } else if (AppState.game.selectedPieceIndex !== null) {
              const movesForSelected = AppState.game.validMoves[AppState.game.selectedPieceIndex] || [];
              if (movesForSelected.some(move => move.to === index)) makeMove(AppState.game.selectedPieceIndex, index);
          }
      }
      
      function makeMove(fromIndex, toIndex) {
          const move = AppState.game.validMoves[fromIndex]?.find(m => m.to === toIndex);
          if (!move) return;
          const pieceBeforeMove = { ...AppState.game.board[fromIndex] };
          let newBoard = [...AppState.game.board];
          newBoard[toIndex] = pieceBeforeMove;
          newBoard[fromIndex] = null;
          const wasCapture = move.captures.length > 0;
          move.captures.forEach(capturedIndex => newBoard[capturedIndex] = null);
          const player = newBoard[toIndex].player;
          const endRow = player === 'X' ? 0 : 7;
          const justPromoted = (Math.floor(toIndex / 8) === endRow && !pieceBeforeMove.isKing);
          if (justPromoted) {
            newBoard[toIndex].isKing = true;
          }
          if (AppState.game.mode === 'coop') {
              updateDoc(doc(db, "rooms", AppState.currentRoom.id), { 
                  "game.board": newBoard, 
                  "game.turn": AppState.game.currentPlayer === 'X' ? 'O' : 'X',
                  "game.lastMove": { from: fromIndex, to: toIndex, player: player, wasCapture: wasCapture, justPromoted: justPromoted },
              });
          } else {
              AppState.game.board = newBoard;
              checkPostMoveState(toIndex, wasCapture, player, justPromoted);
          }
      }

      function checkPostMoveState(currentIndex, wasCapture, player, justPromoted = false) {
          const board = AppState.game.board;
          if (wasCapture && currentIndex !== null && !justPromoted) {
              const piece = board[currentIndex];
              if (piece) {
                  const { captures } = getMovesForPiece(currentIndex, board, player);
                  if (captures.length > 0) {
                      AppState.game.mustContinueJump = true;
                      AppState.game.selectedPieceIndex = currentIndex;
                      AppState.game.validMoves = { [currentIndex]: captures };
                      renderBoard(); return;
                  }
              }
          }
          AppState.game.mustContinueJump = false;
          AppState.game.selectedPieceIndex = null;
          AppState.game.currentPlayer = AppState.game.currentPlayer === 'X' ? 'O' : 'X';
          findAllValidMoves();
          if (Object.keys(AppState.game.validMoves).length === 0) {
              const winner = AppState.game.currentPlayer === 'X' ? 'O' : 'X';
              renderBoard();
              endGame(winner);
              return;
          }
          renderBoard();
          if (AppState.game.mode === 'bot' && AppState.game.currentPlayer === 'O') {
              setTimeout(botMove, 500);
          }
      }
      
      function botMove() {
          if (!AppState.game.isActive) return;
          const movablePieces = Object.keys(AppState.game.validMoves);
          if (movablePieces.length === 0) return;
          const fromIndex = parseInt(movablePieces[Math.floor(Math.random() * movablePieces.length)]);
          const moves = AppState.game.validMoves[fromIndex];
          const move = moves[Math.floor(Math.random() * moves.length)];
          makeMove(fromIndex, move.to);
      }

      function endGame(winner, reason = "") {
          if(!AppState.game.isActive) return;
          AppState.game.isActive = false;
          updateTurnDisplay();
          const playerWon = (AppState.game.mode === 'bot' && winner === 'X') || (AppState.game.mode === 'coop' && winner === AppState.playerSymbol);
          
          if(reason === "disconnect"){
             DOM.gameOverMessage.textContent = "‡∏ù‡πà‡∏≤‡∏¢‡∏ï‡∏£‡∏á‡∏Ç‡πâ‡∏≤‡∏°‡∏≠‡∏≠‡∏Å!";
          } else {
             DOM.gameOverMessage.textContent = playerWon ? "‡∏Ñ‡∏∏‡∏ì‡∏ä‡∏ô‡∏∞!" : "‡∏Ñ‡∏∏‡∏ì‡πÅ‡∏û‡πâ!";
          }
          
          document.getElementById('leave-game-btn').style.display = 'none';
          document.getElementById('cheat-icon').style.display = 'none';
          DOM.gameOverOverlay.classList.remove('hidden');

          if (AppState.game.mode === 'coop' && AppState.currentRoom.data?.players?.[AppState.currentUser.uid]) {
              if(Object.keys(AppState.currentRoom.data.players)[0] === AppState.currentUser.uid){
                 updateDoc(doc(db, "rooms", AppState.currentRoom.id), { status: 'finished', 'game.winner': winner, 'game.rematch': {} });
              }
          }
      }
      
      async function handleCreateRoom(button) {
          button.disabled = true;
          const roomId = Math.random().toString(36).substring(2, 2 + CONST.ROOM_CODE_LENGTH).toUpperCase();
          const creatorSymbol = Math.random() < 0.5 ? 'X' : 'O';
          const startingPlayer = Math.random() < 0.5 ? 'X' : 'O';
          const roomData = {
              status: 'lobby',
              players: { [AppState.currentUser.uid]: { username: AppState.currentUser.username, symbol: creatorSymbol, ready: false }},
              game: { board: [], turn: startingPlayer, winner: null, rematch: {}, lastMove: null }, createdAt: serverTimestamp()
          };
          await setDoc(doc(db, "rooms", roomId), roomData);
          AppState.currentRoom.id = roomId;
          AppState.playerSymbol = creatorSymbol;
          listenToRoomUpdates(roomId);
          showScreen('roomLobby');
          button.disabled = false;
      }

      async function handleJoinRoom() {
            const roomId = document.getElementById('room-code-input').value.trim().toUpperCase();
            if (!roomId) return;
            const roomRef = doc(db, "rooms", roomId);
            try {
              await runTransaction(db, async (t) => {
                  const roomDoc = await t.get(roomRef);
                  if (!roomDoc.exists()) throw new Error("‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏´‡πâ‡∏≠‡∏á‡∏ô‡∏µ‡πâ");
                  const roomData = roomDoc.data();
                  if (Object.keys(roomData.players).length >= 2 && !roomData.players[AppState.currentUser.uid]) throw new Error("‡∏´‡πâ‡∏≠‡∏á‡πÄ‡∏ï‡πá‡∏°‡πÅ‡∏•‡πâ‡∏ß");
                  const existingSymbol = Object.values(roomData.players)[0].symbol;
                  AppState.playerSymbol = existingSymbol === 'X' ? 'O' : 'X';
                  AppState.currentRoom.id = roomId;
                  t.update(roomRef, { [`players.${AppState.currentUser.uid}`]: { username: AppState.currentUser.username, symbol: AppState.playerSymbol, ready: false }});
              });
              listenToRoomUpdates(roomId);
              showScreen('roomLobby');
            } catch (error) { console.error(error); alert(error.message); }
      }

      function listenToRoomUpdates(roomId) {
          if (AppState.listeners.room) AppState.listeners.room();
          const roomRef = doc(db, "rooms", roomId);
          AppState.listeners.room = onSnapshot(roomRef, (docSnap) => {
              if (!docSnap.exists() || !docSnap.data().players[AppState.currentUser.uid]) {
                  cleanupAfterRoom();
                  return;
              }

              const newData = docSnap.data();
              const oldData = AppState.currentRoom.data;
              AppState.currentRoom.data = newData;
              
              const currentScreen = document.querySelector('.screen.active')?.id;

              if (newData.status === 'playing' && Object.keys(newData.players).length < 2) {
                  endGame(AppState.playerSymbol, "disconnect");
                  return;
              }

              if (newData.status === 'lobby') {
                  if(currentScreen !== 'room-lobby') showScreen('roomLobby');
                  updateLobbyUI(newData);
              } else if (newData.status === 'playing') {
                  if (oldData?.status !== 'playing') {
                     AppState.game.mode = 'coop'; 
                     startGame();
                  } else {
                     if(JSON.stringify(oldData.game.board) !== JSON.stringify(newData.game.board)) {
                        AppState.game.board = newData.game.board;
                     }
                     if(oldData.game.turn !== newData.game.turn) {
                        AppState.game.currentPlayer = newData.game.turn;
                     }

                     AppState.game.selectedPieceIndex = null;
                     AppState.game.mustContinueJump = false;
                     
                     const { lastMove } = newData.game;
                     if (lastMove && lastMove.player !== AppState.playerSymbol && lastMove.wasCapture && !lastMove.justPromoted) {
                        const piece = AppState.game.board[lastMove.to];
                        if (piece && piece.player === AppState.game.currentPlayer) {
                           const { captures } = getMovesForPiece(lastMove.to, AppState.game.board, piece.player);
                           if (captures.length > 0) {
                               AppState.game.mustContinueJump = true;
                               AppState.game.selectedPieceIndex = lastMove.to;
                               AppState.game.validMoves = { [lastMove.to]: captures };
                           }
                        }
                     }
                     
                     if (!AppState.game.mustContinueJump) {
                         findAllValidMoves();
                     }
                     renderBoard();
                  }
              } else if (newData.status === 'finished' && AppState.game.isActive) {
                  endGame(newData.game.winner);
              }

              if(newData.game.rematch) updateRematchStatusUI(newData.game.rematch);
          });
      }

      function updateLobbyUI(data) {
          document.getElementById('room-code-display').innerText = AppState.currentRoom.id;
          const playerListDiv = document.getElementById('player-list');
          playerListDiv.innerHTML = '';
          let allReady = Object.keys(data.players).length === 2;
          Object.values(data.players).forEach(p => {
              playerListDiv.innerHTML += `<div class="p-2 bg-slate-700 rounded-md">${p.username} (${p.symbol}) - <span class="${p.ready ? 'text-green-400' : 'text-rose-400'}">${p.ready ? '‡∏û‡∏£‡πâ‡∏≠‡∏°' : '‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡∏û‡∏£‡πâ‡∏≠‡∏°'}</span></div>`;
              if (!p.ready) allReady = false;
          });
          if (allReady && Object.keys(data.players)[0] === AppState.currentUser.uid) {
              updateDoc(doc(db, "rooms", AppState.currentRoom.id), { status: 'playing', "game.board": createInitialBoard() });
          }
      }

      async function handleReadyClick() {
          const ready = AppState.currentRoom.data.players[AppState.currentUser.uid]?.ready || false;
          await updateDoc(doc(db, "rooms", AppState.currentRoom.id), { [`players.${AppState.currentUser.uid}.ready`]: !ready });
      }

      async function handleRematchRequest(button) {
          button.disabled = true;
          await updateDoc(doc(db, "rooms", AppState.currentRoom.id), { [`game.rematch.${AppState.currentUser.uid}`]: true });
      }

      function updateRematchStatusUI(rematchData) {
          const uids = Object.keys(AppState.currentRoom.data.players);
          if(uids.length < 2) return;
          const myUid = AppState.currentUser.uid;
          const opponentUid = uids.find(uid => uid !== myUid);

          if (rematchData[myUid] && rematchData[opponentUid]) {
              if (uids[0] === myUid) {
                  updateDoc(doc(db, "rooms", AppState.currentRoom.id), {
                      status: "playing",
                      'game.board': createInitialBoard(),
                      'game.turn': Math.random() < 0.5 ? 'X' : 'O',
                      'game.winner': null,
                      'game.rematch': {},
                      'game.lastMove': null
                  });
              }
          } else if (rematchData[myUid]) {
              DOM.rematchStatus.textContent = "‡∏Ñ‡∏∏‡∏ì‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡πÄ‡∏•‡πà‡∏ô‡∏≠‡∏µ‡∏Å‡∏Ñ‡∏£‡∏±‡πâ‡∏á ‡∏£‡∏≠‡∏≠‡∏µ‡∏Å‡∏ù‡πà‡∏≤‡∏¢...";
          } else if (rematchData[opponentUid]) {
              DOM.rematchStatus.textContent = "‡∏≠‡∏µ‡∏Å‡∏ù‡πà‡∏≤‡∏¢‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡πÄ‡∏•‡πà‡∏ô‡∏≠‡∏µ‡∏Å‡∏Ñ‡∏£‡∏±‡πâ‡∏á!";
          } else {
              DOM.rematchStatus.textContent = "";
          }
      }

      async function leaveRoom() {
            if(!AppState.currentRoom.id) return;
            const roomRef = doc(db, "rooms", AppState.currentRoom.id);
            try {
                await runTransaction(db, async (t) => {
                    const roomDoc = await t.get(roomRef);
                    if(!roomDoc.exists()) return;
                    const roomData = roomDoc.data();
                    const newPlayers = {...roomData.players};
                    delete newPlayers[AppState.currentUser.uid];
                    if(Object.keys(newPlayers).length < 1) {
                        t.delete(roomRef);
                    } else {
                        t.update(roomRef, { players: newPlayers });
                    }
                });
            } catch (e) { console.error("Error leaving room:", e); }
            cleanupAfterRoom();
        }

      function cleanupAfterRoom() {
          if (AppState.listeners.room) { AppState.listeners.room(); AppState.listeners.room = null; }
          AppState.currentRoom = { id: null, data: null };
          AppState.playerSymbol = '';
          showScreen('mainMenu');
      }

      async function handleCheatCode() {
        const input = document.getElementById('cheat-code-input');
        const code = parseInt(input.value);

        if (code === CONST.SECRET_CODE) {
            const playerSymbol = AppState.playerSymbol;
            let piecesRevived = 0;
            const startRow1 = playerSymbol === 'X' ? 7 : 0;
            const startRow2 = playerSymbol === 'X' ? 6 : 1;
            const searchRows = [startRow1, startRow2];
            let newBoard = [...AppState.game.board];

            for (const row of searchRows) {
                if (piecesRevived >= 2) break;
                for (let col = 0; col < CONST.BOARD_SIZE; col++) {
                    if (piecesRevived >= 2) break;
                    if ((row + col) % 2 !== 0) {
                        const index = row * CONST.BOARD_SIZE + col;
                        if (newBoard[index] === null) {
                            newBoard[index] = { player: playerSymbol, isKing: false };
                            piecesRevived++;
                        }
                    }
                }
            }

            if (piecesRevived > 0) {
                await updateDoc(doc(db, "rooms", AppState.currentRoom.id), { 
                    "game.board": newBoard,
                });
            }
        }
        input.value = '';
        DOM.cheatModal.classList.add('hidden');
        DOM.cheatModal.classList.remove('flex');
    }

      function addEventListeners() {
          document.getElementById('play-bot-btn').onclick = () => { AppState.game.mode = 'bot'; startGame(); };
          document.getElementById('play-coop-btn').onclick = () => showScreen('coopMenu');
          document.getElementById('back-to-main-from-coop-btn').onclick = () => showScreen('mainMenu');
          document.getElementById('create-room-btn').onclick = (e) => handleCreateRoom(e.currentTarget);
          document.getElementById('join-room-btn').onclick = handleJoinRoom;
          document.getElementById('ready-btn').onclick = handleReadyClick;
          document.getElementById('leave-room-btn').onclick = leaveRoom;
          document.getElementById('leave-game-btn').onclick = () => {
              if(AppState.game.mode === 'coop') {
                  const winner = AppState.playerSymbol === 'X' ? 'O' : 'X';
                  updateDoc(doc(db, "rooms", AppState.currentRoom.id), { status: 'finished', 'game.winner': winner, reason: 'surrender' });
              } else {
                 showScreen('mainMenu');
              }
          };

          DOM.gameBoard.addEventListener('click', (e) => {
              const cell = e.target.closest('.cell');
              if (cell) handleCellClick(parseInt(cell.dataset.index));
          });
          document.getElementById('back-to-menu-from-game-btn').onclick = () => {
              if (AppState.game.mode === 'coop') cleanupAfterRoom(); else showScreen('mainMenu');
          };
          DOM.rematchBtn.onclick = (e) => {
              if (AppState.game.mode === 'bot') startGame();
              else handleRematchRequest(e.currentTarget);
          };

          document.getElementById('cheat-icon').onclick = () => {
              if (AppState.game.mode === 'coop') {
                  DOM.cheatModal.classList.remove('hidden');
                  DOM.cheatModal.classList.add('flex');
              }
          };
          document.getElementById('close-cheat-btn').onclick = () => {
              DOM.cheatModal.classList.add('hidden');
              DOM.cheatModal.classList.remove('flex');
          };
          document.getElementById('submit-cheat-btn').onclick = handleCheatCode;
      }
      
      function showScreen(screenName) {
          Object.values(DOM.screens).forEach(s => s.classList.remove('active'));
          DOM.screens[screenName].classList.add('active');
      }
      
      init();
  </script>
</body>
</html>

