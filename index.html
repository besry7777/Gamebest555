<!DOCTYPE html>
<html lang="th">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Lua Learning Studio Pro</title>
    <style>
        :root {
            --bg-color: #2e2e2e;
            --panel-bg: #252526;
            --editor-bg: #1e1e1e;
            --primary-text: #d4d4d4;
            --secondary-text: #a0a0a0;
            --accent-color: #007acc;
            --error-color: #f44747;
            --success-color: #4CAF50;
            --font-family: Consolas, 'Courier New', monospace;
            
            /* Syntax Highlighting Colors (Roblox-like) */
            --hl-keyword: #569cd6; /* blue */
            --hl-string: #ce9178; /* orange-red */
            --hl-number: #b5cea8; /* aqua-green */
            --hl-comment: #6a9955; /* green */
            --hl-global: #4fc1ff; /* light blue */
        }
        * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
        html, body { margin: 0; padding: 0; height: 100%; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif; background-color: var(--bg-color); color: var(--primary-text); touch-action: manipulation; overflow: hidden; }

        #main-layout { display: flex; height: 100vh; }

        /* --- Explorer Panel (NEW) --- */
        #explorer-panel {
            width: 240px;
            background-color: var(--panel-bg);
            display: flex;
            flex-direction: column;
            border-right: 1px solid #444;
            flex-shrink: 0;
        }
        .panel-header {
            padding: 10px;
            font-weight: bold;
            background-color: #333;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .add-item-btn {
            background: var(--accent-color);
            border: none;
            color: white;
            border-radius: 4px;
            cursor: pointer;
            padding: 2px 6px;
        }
        #explorer-content { flex-grow: 1; overflow-y: auto; padding: 10px; font-family: var(--font-family); font-size: 0.9em; }
        .explorer-item { padding: 4px 0; white-space: nowrap; }
        .explorer-item span { margin-left: 8px; }
        .explorer-item[data-depth='1'] { padding-left: 15px; }
        .explorer-item[data-depth='2'] { padding-left: 30px; }
        .explorer-item::before {
            font-family: monospace;
            content: 'üìÑ'; /* Default icon */
            margin-right: 5px;
        }
        .explorer-item[data-type='Workspace']::before { content: 'üåç'; }
        .explorer-item[data-type='ServerScriptService']::before { content: '‚öôÔ∏è'; }
        .explorer-item[data-type='Part']::before { content: 'üì¶'; }
        .explorer-item[data-type='Script']::before { content: 'üìú'; }


        /* --- Main Content Area --- */
        #main-content {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            height: 100vh;
        }
        #script-manager { display: flex; align-items: center; background-color: #333; padding: 5px; overflow-x: auto; flex-shrink: 0;}
        #script-tabs { display: flex; flex-grow: 1; }
        .tab { padding: 8px 12px; cursor: pointer; border-radius: 4px 4px 0 0; margin-right: 4px; background-color: var(--editor-bg); color: var(--secondary-text); white-space: nowrap; border: 1px solid transparent; }
        .tab.active { background-color: var(--bg-color); color: var(--primary-text); border-color: #444 #444 transparent #444; }
        #add-script-btn { background-color: var(--accent-color); color: white; border: none; border-radius: 50%; width: 28px; height: 28px; font-size: 1.2em; cursor: pointer; flex-shrink: 0; }

        /* --- Editor with Syntax Highlighting (UPGRADED) --- */
        #editor-container { flex-grow: 1; position: relative; background-color: var(--editor-bg); }
        #code-editor, #highlighting-layer {
            margin: 0;
            padding: 10px;
            font-family: var(--font-family);
            font-size: 16px;
            line-height: 1.5;
            border: none;
            outline: none;
            width: 100%;
            height: 100%;
            position: absolute;
            top: 0;
            left: 0;
            overflow: auto;
            white-space: pre;
            word-wrap: normal;
        }
        #code-editor {
            z-index: 1;
            background: transparent;
            color: transparent; /* Hide original text */
            caret-color: white; /* Show cursor */
            resize: none;
        }
        #highlighting-layer {
            z-index: 0;
            pointer-events: none; /* Let clicks pass through to textarea */
        }
        .hl-keyword { color: var(--hl-keyword); }
        .hl-string { color: var(--hl-string); }
        .hl-number { color: var(--hl-number); }
        .hl-comment { color: var(--hl-comment); }
        .hl-global { color: var(--hl-global); }


        #autocomplete-popup { position: absolute; background-color: #3c3c3c; border: 1px solid #555; border-radius: 4px; min-width: 150px; max-height: 200px; overflow-y: auto; z-index: 1000; color: var(--primary-text); }
        .autocomplete-item { padding: 8px 12px; cursor: pointer; }
        .autocomplete-item:hover, .autocomplete-item.selected { background-color: var(--accent-color); }
        .hidden { display: none; }

        #bottom-panel { flex-shrink: 0; border-top: 1px solid #444; }
        #controls { padding: 10px; background-color: var(--panel-bg); display: flex; gap: 10px; }
        #run-button { flex-grow: 1; padding: 12px; background-color: var(--success-color); color: white; border: none; border-radius: 5px; font-size: 1.2em; cursor: pointer; font-weight: bold; }
        #clear-output-btn { padding: 12px 15px; background-color: #5a5a5a; color: white; border: none; border-radius: 5px; font-size: 1.2em; cursor: pointer; }

        #output-chat { height: 180px; background-color: var(--panel-bg); padding: 10px; overflow-y: auto; font-family: var(--font-family); font-size: 0.9em; }
        .output-line { padding: 4px 0; white-space: pre-wrap; word-break: break-all; }
        .output-line.error { color: var(--error-color); } .output-line.success { color: var(--success-color); } .output-line.info { color: var(--secondary-text); } .output-line.print { color: #87ceeb; }
    </style>
</head>
<body>
    <div id="main-layout">
        <div id="explorer-panel">
            <div class="panel-header">
                <span>Explorer</span>
                <div class="controls">
                    <button id="add-part-btn" class="add-item-btn" title="Add Part to Workspace">+</button>
                </div>
            </div>
            <div id="explorer-content"></div>
        </div>
        <div id="main-content">
            <div id="script-manager">
                <div id="script-tabs"></div>
                <button id="add-script-btn">+</button>
            </div>
            <div id="editor-container">
                <textarea id="code-editor" spellcheck="false" autocomplete="off" autocorrect="off" autocapitalize="off"></textarea>
                <pre id="highlighting-layer-container"><code id="highlighting-layer"></code></pre>
                <div id="autocomplete-popup" class="hidden"></div>
            </div>
            <div id="bottom-panel">
                 <div id="controls">
                    <button id="run-button">‚ñ∂Ô∏è Run</button>
                    <button id="clear-output-btn" title="Clear Output">üóëÔ∏è</button>
                </div>
                <div id="output-chat"></div>
            </div>
        </div>
    </div>

    <script src="https://unpkg.com/fengari-web@0.1.4/dist/fengari-web.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const getEl = (id) => document.getElementById(id);
            const codeEditor = getEl('code-editor');
            const highlightingLayer = getEl('highlighting-layer');
            const autocompletePopup = getEl('autocomplete-popup');
            const explorerContent = getEl('explorer-content');
            
            // --- Global State ---
            let mockGame = {
                Workspace: { _children: {}, ClassName: 'Workspace' },
                ServerScriptService: { _children: {}, ClassName: 'ServerScriptService' }
            };
            let scripts = [
                { name: 'Script', code: 'local part = game.Workspace:FindFirstChild("MyPart")\nif part then\n\tpart.Name = "RenamedPart"\n\tprint("Part has been renamed!")\nelse\n\tprint("MyPart not found. Add it using the Explorer!")\nend' }
            ];
            let activeScriptIndex = 0;
            let partCounter = 1;

            // --- Syntax Highlighting Logic ---
            const syntaxPatterns = {
                comment: /(--.*)/g,
                string: /("(?:[^"\\]|\\.)*"|'(?:[^'\\]|\\.)*')/g,
                number: /\b(\d+(\.\d+)?)\b/g,
                keyword: /\b(local|function|if|then|else|elseif|end|for|while|do|return|and|or|not|break|in|repeat|until)\b/g,
                global: /\b(game|print|workspace|wait|script|math)\b/g
            };
            function updateHighlighting() {
                let code = codeEditor.value;
                // Add a newline to fix last line highlighting bug
                if(!code.endsWith('\n')) code += '\n';

                // Escape HTML characters
                code = code.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
                
                // Apply syntax colors
                code = code.replace(syntaxPatterns.string, '<span class="hl-string">$1</span>');
                code = code.replace(syntaxPatterns.comment, '<span class="hl-comment">$1</span>');
                code = code.replace(syntaxPatterns.keyword, '<span class="hl-keyword">$1</span>');
                code = code.replace(syntaxPatterns.global, '<span class="hl-global">$1</span>');
                code = code.replace(syntaxPatterns.number, '<span class="hl-number">$1</span>');
                
                highlightingLayer.innerHTML = code;
            }

            // --- Explorer Logic ---
            function renderExplorer() {
                explorerContent.innerHTML = '';
                function renderNode(name, object, depth) {
                    const item = document.createElement('div');
                    item.className = 'explorer-item';
                    item.dataset.depth = depth;
                    item.dataset.type = object.ClassName;
                    item.innerHTML = `<span>${name}</span>`;
                    explorerContent.appendChild(item);
                    if (object._children) {
                        for (const childName in object._children) {
                            renderNode(childName, object._children[childName], depth + 1);
                        }
                    }
                }
                renderNode('game', { _children: mockGame, ClassName: 'DataModel' }, 0);
            }
            getEl('add-part-btn').addEventListener('click', () => {
                const partName = `Part${partCounter++}`;
                mockGame.Workspace._children[partName] = { Name: partName, ClassName: 'Part', Position: {x:0, y:0, z:0} };
                renderExplorer();
            });


            // --- Advanced Editor Features ---
            const autoClosePairs = { '(': ')', '{': '}', '[': ']', '"': '"', "'": "'" };
            codeEditor.addEventListener('keydown', (e) => {
                if(autoClosePairs[e.key]) {
                    e.preventDefault();
                    const { value, selectionStart, selectionEnd } = codeEditor;
                    const textBefore = value.substring(0, selectionStart);
                    const textAfter = value.substring(selectionEnd);
                    codeEditor.value = textBefore + e.key + autoClosePairs[e.key] + textAfter;
                    codeEditor.selectionStart = codeEditor.selectionEnd = selectionStart + 1;
                    updateHighlighting();
                }
                // Handle autocomplete keydown
                if (autocompleteActive) {
                    if (e.key === 'ArrowDown') { e.preventDefault(); selectedSuggestionIndex = (selectedSuggestionIndex + 1) % currentSuggestions.length; updateSelectedSuggestion(); } 
                    else if (e.key === 'ArrowUp') { e.preventDefault(); selectedSuggestionIndex = (selectedSuggestionIndex - 1 + currentSuggestions.length) % currentSuggestions.length; updateSelectedSuggestion(); } 
                    else if (e.key === 'Tab' || e.key === 'Enter') { e.preventDefault(); applySuggestion(selectedSuggestionIndex > -1 ? selectedSuggestionIndex : 0); } 
                    else if (e.key === 'Escape') { hideAutocomplete(); }
                }
            });

            // Sync scroll
            codeEditor.addEventListener('scroll', () => {
                highlightingLayer.parentElement.scrollTop = codeEditor.scrollTop;
                highlightingLayer.parentElement.scrollLeft = codeEditor.scrollLeft;
            });
            codeEditor.addEventListener('input', updateHighlighting);


            // --- Autocomplete Logic (Upgraded) ---
            const autocompleteKeywords = {
                global: ['local', 'function', 'if', 'then', 'else', 'elseif', 'end', 'for', 'while', 'do', 'return', 'print', 'game', 'true', 'false', 'nil'],
                game: ['Workspace', 'ServerScriptService'],
                Workspace: ['Create', 'FindFirstChild'],
                Part: ['Name', 'Position', 'Parent', 'ClassName']
            };
            let autocompleteActive = false, currentSuggestions = [], selectedSuggestionIndex = -1;
            
            function showAutocomplete(suggestions, left, top) { /* ... (same as before) ... */
                if (suggestions.length === 0) { hideAutocomplete(); return; }
                autocompletePopup.innerHTML = '';
                suggestions.forEach((item, index) => {
                    const div = document.createElement('div');
                    div.className = 'autocomplete-item';
                    div.textContent = item;
                    div.onmousedown = (e) => { e.preventDefault(); applySuggestion(index); }; // Use onmousedown for better mobile tap
                    autocompletePopup.appendChild(div);
                });
                autocompletePopup.style.left = `${left}px`;
                autocompletePopup.style.top = `${top}px`;
                autocompletePopup.classList.remove('hidden');
                autocompleteActive = true;
                selectedSuggestionIndex = -1;
            }
            function hideAutocomplete() { /* ... (same) ... */
                autocompletePopup.classList.add('hidden');
                autocompleteActive = false;
            }
            function updateSelectedSuggestion() { /* ... (same) ... */
                 const items = autocompletePopup.children;
                 for (let i = 0; i < items.length; i++) { items[i].classList.toggle('selected', i === selectedSuggestionIndex); }
            }
            function applySuggestion(index) { /* ... (same) ... */
                if (index < 0 || index >= currentSuggestions.length) return;
                const suggestion = currentSuggestions[index];
                const { value, selectionStart } = codeEditor;
                let wordBoundary = value.substring(0, selectionStart).search(/[\w\.]*$/);
                const textBefore = value.substring(0, wordBoundary);
                const textAfter = value.substring(selectionStart);
                codeEditor.value = textBefore + suggestion + textAfter;
                codeEditor.selectionStart = codeEditor.selectionEnd = textBefore.length + suggestion.length;
                hideAutocomplete();
                updateHighlighting();
                codeEditor.focus();
            }
            function getCursorCoords() { /* ... (same simplified version) ... */
                const dummy = document.createElement('div');
                const styles = window.getComputedStyle(codeEditor);
                for(const prop of styles) { dummy.style[prop] = styles[prop]; }
                dummy.style.position = 'absolute'; dummy.style.visibility = 'hidden'; dummy.style.height = 'auto';
                const text = codeEditor.value.substring(0, codeEditor.selectionStart);
                dummy.textContent = text;
                const span = document.createElement('span');
                span.textContent = codeEditor.value.substring(codeEditor.selectionStart) || '.';
                dummy.appendChild(span);
                document.body.appendChild(dummy);
                const { offsetLeft, offsetTop, clientHeight } = span;
                document.body.removeChild(dummy);
                return { left: offsetLeft + codeEditor.offsetLeft - codeEditor.scrollLeft + 10, top: offsetTop + codeEditor.offsetTop - codeEditor.scrollTop + clientHeight + 5 };
            }

            codeEditor.addEventListener('input', (e) => {
                const { value, selectionStart } = codeEditor;
                if (selectionStart === 0 || e.inputType === "insertLineBreak") { hideAutocomplete(); return; }
                
                let textBeforeCursor = value.substring(0, selectionStart);
                let wordMatch = textBeforeCursor.match(/[\w\.]+$/);
                if(!wordMatch) { hideAutocomplete(); return; }

                let fullTerm = wordMatch[0];
                let parts = fullTerm.split('.');
                let currentWord = parts.pop();
                let contextTerm = parts.join('.');
                
                let context = 'global';
                // Very basic context detection
                if (contextTerm === 'game') context = 'game';
                else if (contextTerm === 'game.Workspace') context = 'Workspace';
                else if (contextTerm.endsWith('part')) context = 'Part'; // Simple check

                if (currentWord === undefined) { hideAutocomplete(); return; }

                currentSuggestions = (autocompleteKeywords[context] || []).filter(k => k.toLowerCase().startsWith(currentWord.toLowerCase()));
                if (currentSuggestions.length > 0) { const coords = getCursorCoords(); showAutocomplete(currentSuggestions, coords.left, coords.top); } 
                else { hideAutocomplete(); }
            });

            codeEditor.addEventListener('blur', () => setTimeout(hideAutocomplete, 200));

            // --- Script & Execution Management ---
            const scriptTabsContainer = getEl('script-tabs');
            function switchScript(index) {
                scripts[activeScriptIndex].code = codeEditor.value;
                activeScriptIndex = index;
                codeEditor.value = scripts[index].code;
                renderTabs();
                updateHighlighting();
            }
            function renderTabs() {
                scriptTabsContainer.innerHTML = '';
                scripts.forEach((script, index) => {
                    const tab = document.createElement('div');
                    tab.className = 'tab' + (index === activeScriptIndex ? ' active' : '');
                    tab.textContent = script.name;
                    tab.onclick = () => switchScript(index);
                    scriptTabsContainer.appendChild(tab);
                });
            }
            getEl('add-script-btn').addEventListener('click', () => {
                const newName = `Script${scripts.length + 1}`;
                scripts.push({ name: newName, code: `-- New script: ${newName}` });
                switchScript(scripts.length - 1);
            });
            
            const outputChat = getEl('output-chat');
            const logToOutput = (message, type = 'info') => { /* ... (same) ... */ const line = document.createElement('div'); line.className = `output-line ${type}`; line.textContent = message; outputChat.appendChild(line); outputChat.scrollTop = outputChat.scrollHeight; };
            getEl('clear-output-btn').addEventListener('click', () => { outputChat.innerHTML = ''; logToOutput('-- Output cleared --', 'info'); });

            getEl('run-button').addEventListener('click', () => {
                scripts[activeScriptIndex].code = codeEditor.value;
                outputChat.innerHTML = '';
                logToOutput("> Starting execution...", "info");
                try {
                    const L = fengari.lauxlib.luaL_newstate();
                    fengari.lualib.luaL_openlibs(L);
                    
                    // Remock the game environment for execution
                    const executionGame = JSON.parse(JSON.stringify(mockGame)); // Deep copy to prevent direct modification
                    const createdObjects = [];
                    
                    function jsToLua(obj, name) {
                        fengari.lua.lua_createtable(L, 0, 5);
                        for(const key in obj) {
                            if (key === '_children') continue;
                            const value = obj[key];
                            if (typeof value === 'object' && value !== null) {
                                jsToLua(value, key);
                            } else {
                                fengari.lua.lua_pushjs(L, value);
                                fengari.lua.lua_setfield(L, -2, fengari.to_luastring(key));
                            }
                        }
                        if(name) fengari.lua.lua_setfield(L, -2, fengari.to_luastring(name));
                    }
                    
                    function FindFirstChild(parent) { return (name) => { return parent._children[fengari.to_jsstring(name)] || null; }; }
                    function Create(parent) { return (className) => {
                            const name = fengari.to_jsstring(className);
                            const newObj = { Name: name, ClassName: name, Position: {x:0, y:0, z:0} };
                            createdObjects.push({parent: parent, name:name, obj: newObj});
                            logToOutput(`[‡∏à‡∏≥‡∏•‡∏≠‡∏á] ‡∏™‡∏Ñ‡∏£‡∏¥‡∏õ‡∏ï‡πå‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏à‡∏∞‡∏™‡∏£‡πâ‡∏≤‡∏á '${name}' ‡πÉ‡∏ô '${parent.ClassName}'`, 'success');
                            return newObj;
                        };
                    }
                    
                    function setupLuaEnvironment(obj, path) {
                        for(const key in obj) {
                            if (key === '_children') {
                                for(const childKey in obj._children) {
                                    setupLuaEnvironment(obj._children[childKey], `${path}.${childKey}`);
                                }
                            }
                        }
                        // This is a simplified binding. A full one is more complex.
                        if(path === "game.Workspace") {
                            fengari.lua.lua_getglobal(L, fengari.to_luastring("game"));
                            fengari.lua.lua_getfield(L, -1, fengari.to_luastring("Workspace"));
                            fengari.lua.lua_pushjs(L, Create(executionGame.Workspace));
                            fengari.lua.lua_setfield(L, -2, fengari.to_luastring("Create"));
                            fengari.lua.lua_pushjs(L, FindFirstChild(executionGame.Workspace));
                            fengari.lua.lua_setfield(L, -2, fengari.to_luastring("FindFirstChild"));
                            fengari.lua.lua_pop(L, 2);
                        }
                    }
                    
                    jsToLua({game: executionGame});
                    fengari.lua.lua_getglobal(L, fengari.to_luastring("game"));
                    fengari.lua.lua_setglobal(L, fengari.to_luastring("game"));
                    setupLuaEnvironment(executionGame, 'game');
                    
                    fengari.lua.lua_pushjs(L, (...args) => { const message = args.map(arg => fengari.to_jsstring(arg)).join('\t'); logToOutput(message, 'print'); });
                    fengari.lua.lua_setglobal(L, fengari.to_luastring("print"));
                    
                    let allScriptsOk = true;
                    for (const script of scripts) {
                        logToOutput(`--- Running ${script.name} ---`, 'info');
                        const status = fengari.lauxlib.luaL_dostring(L, fengari.to_luastring(script.code));
                        if (status !== fengari.lua.LUA_OK) { /* ... error handling ... */ const errorMsg = fengari.to_jsstring(fengari.lua.lua_tostring(L, -1)); const lineMatch = errorMsg.match(/\[string "..."\]:(\d+):/); const lineNumber = lineMatch ? lineMatch[1] : "?"; logToOutput(`[ERROR] ‡πÉ‡∏ô '${script.name}' ‡∏ö‡∏£‡∏£‡∏ó‡∏±‡∏î ${lineNumber}: ` + errorMsg.split(':').slice(2).join(':').trim(), 'error'); allScriptsOk = false; break; }
                    }

                    if(allScriptsOk) {
                        logToOutput("> Execution finished.", "success");
                        // Apply changes to the main mockGame object
                        createdObjects.forEach(c => {
                             if(c.parent.ClassName === 'Workspace') mockGame.Workspace._children[c.name] = c.obj;
                        });
                        // A real implementation would need to track all property changes, this is a simplification.
                        renderExplorer();
                    }

                } catch (e) { logToOutput("[FATAL ERROR]: " + e.message, "error"); }
            });

            // --- Initial Setup ---
            switchScript(0);
            renderExplorer();
            logToOutput("-- Lua Studio Pro loaded --", "info");
        });
    </script>
</body>
</html>
