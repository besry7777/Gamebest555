<!DOCTYPE html>
<html lang="th">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Lua Learning Studio Pro</title>
    <style>
        :root {
            --bg-color: #2e2e2e;
            --panel-bg: #252526;
            --editor-bg: #1e1e1e;
            --primary-text: #d4d4d4;
            --secondary-text: #a0a0a0;
            --accent-color: #007acc;
            --error-color: #f44747;
            --success-color: #4CAF50;
            --font-family: Consolas, 'Courier New', monospace;
            
            --hl-keyword: #569cd6; --hl-string: #ce9178; --hl-number: #b5cea8;
            --hl-comment: #6a9955; --hl-global: #4fc1ff;
        }
        * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
        html, body { margin: 0; padding: 0; height: 100%; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif; background-color: var(--bg-color); color: var(--primary-text); touch-action: manipulation; overflow: hidden; }

        #main-layout { display: flex; height: 100vh; }

        /* --- UPGRADED: Explorer Panel --- */
        #explorer-panel {
            width: 240px;
            background-color: var(--panel-bg);
            display: flex;
            flex-direction: column;
            border-right: 1px solid #444;
            flex-shrink: 0;
            transition: width 0.3s ease, padding 0.3s ease;
            position: relative;
        }
        #explorer-panel.collapsed { width: 0; padding: 0; border-right: none; overflow: hidden; }
        .panel-header { padding: 10px; font-weight: bold; background-color: #333; display: flex; justify-content: space-between; align-items: center; }
        #explorer-toggle-btn { background: none; border: none; color: var(--secondary-text); cursor: pointer; font-size: 1.2em; }
        #explorer-toggle-btn.collapsed-btn { position: fixed; top: 5px; left: 5px; z-index: 2000; background: #444; border-radius: 4px; display: none;}
        #explorer-panel.collapsed + #main-content #explorer-toggle-btn.collapsed-btn { display: block; }
        
        .add-item-btn { background: var(--accent-color); border: none; color: white; border-radius: 4px; cursor: pointer; padding: 2px 8px; font-size: 1.1em; }
        #explorer-content { flex-grow: 1; overflow-y: auto; padding: 10px; font-family: var(--font-family); font-size: 0.9em; }
        .explorer-item { padding: 4px 0; white-space: nowrap; cursor: pointer; border-radius: 3px; }
        .explorer-item:hover { background-color: #3a3a3a; }
        .explorer-item span { margin-left: 8px; }
        .explorer-item[data-depth='1'] { padding-left: 15px; } .explorer-item[data-depth='2'] { padding-left: 30px; }
        .explorer-item::before { font-family: monospace; content: 'üìÑ'; margin-right: 5px; }
        .explorer-item[data-type='Workspace']::before { content: 'üåç'; }
        .explorer-item[data-type='ServerScriptService']::before { content: '‚öôÔ∏è'; }
        .explorer-item[data-type='ReplicatedStorage']::before { content: 'üì¶'; }
        .explorer-item[data-type='Part']::before { content: 'üß±'; }
        .explorer-item[data-type='Script']::before { content: 'üìú'; }
        .explorer-item[data-type='RemoteEvent']::before { content: '‚ö°'; }
        .explorer-item-input { background: #555; border: 1px solid var(--accent-color); color: white; font: inherit; outline: none; width: 120px; }
        
        #add-item-menu { display: none; position: absolute; top: 38px; right: 10px; background: #3c3c3c; border: 1px solid #555; border-radius: 4px; z-index: 1500; padding: 5px; }
        #add-item-menu ul { list-style: none; margin: 0; padding: 0; }
        #add-item-menu li { padding: 8px 12px; cursor: pointer; white-space: nowrap; }
        #add-item-menu li:hover { background-color: var(--accent-color); }

        /* --- Main Content Area --- */
        #main-content { flex-grow: 1; display: flex; flex-direction: column; height: 100vh; }
        #script-manager { display: flex; align-items: center; background-color: #333; padding: 5px; overflow-x: auto; flex-shrink: 0;}
        #script-tabs { display: flex; flex-grow: 1; }
        .tab { padding: 8px 12px; cursor: pointer; border-radius: 4px 4px 0 0; margin-right: 4px; background-color: var(--editor-bg); color: var(--secondary-text); white-space: nowrap; border: 1px solid transparent; }
        .tab.active { background-color: var(--bg-color); color: var(--primary-text); border-color: #444 #444 transparent #444; }
        #add-script-btn { background-color: var(--accent-color); color: white; border: none; border-radius: 50%; width: 28px; height: 28px; font-size: 1.2em; cursor: pointer; flex-shrink: 0; }
        
        #editor-container { flex-grow: 1; position: relative; background-color: var(--editor-bg); }
        #code-editor, #highlighting-layer-container { margin: 0; padding: 10px; font-family: var(--font-family); font-size: 16px; line-height: 1.5; border: none; outline: none; width: 100%; height: 100%; position: absolute; top: 0; left: 0; overflow: auto; white-space: pre; word-wrap: normal; }
        #code-editor { z-index: 1; background: transparent; color: transparent; caret-color: white; resize: none; }
        #highlighting-layer-container { z-index: 0; pointer-events: none; }

        #autocomplete-popup { position: absolute; background-color: #3c3c3c; border: 1px solid #555; border-radius: 4px; min-width: 150px; max-height: 200px; overflow-y: auto; z-index: 1000; color: var(--primary-text); }
        .autocomplete-item { padding: 8px 12px; cursor: pointer; }
        .autocomplete-item:hover, .autocomplete-item.selected { background-color: var(--accent-color); }
        .hidden { display: none; }

        #bottom-panel { flex-shrink: 0; border-top: 1px solid #444; }
        #controls { padding: 10px; background-color: var(--panel-bg); display: flex; gap: 10px; }
        #run-button { flex-grow: 1; padding: 12px; background-color: var(--success-color); color: white; border: none; border-radius: 5px; font-size: 1.2em; cursor: pointer; font-weight: bold; }
        #clear-output-btn { padding: 12px 15px; background-color: #5a5a5a; color: white; border: none; border-radius: 5px; font-size: 1.2em; cursor: pointer; }

        #output-chat { height: 180px; background-color: var(--panel-bg); padding: 10px; overflow-y: auto; font-family: var(--font-family); font-size: 0.9em; }
        .output-line { padding: 4px 0; white-space: pre-wrap; word-break: break-all; } .output-line.error { color: var(--error-color); } .output-line.success { color: var(--success-color); } .output-line.info { color: var(--secondary-text); } .output-line.print { color: #87ceeb; }
    </style>
</head>
<body>
    <div id="main-layout">
        <div id="explorer-panel">
            <div class="panel-header">
                <button id="explorer-toggle-btn">¬´</button>
                <span>Explorer</span>
                <div class="controls">
                    <button id="show-add-menu-btn" class="add-item-btn">+</button>
                </div>
            </div>
            <div id="explorer-content"></div>
            <div id="add-item-menu">
                <ul>
                    <li data-parent="Workspace" data-type="Part">Part in Workspace</li>
                    <li data-parent="Workspace" data-type="Script">Script in Workspace</li>
                    <li data-parent="ServerScriptService" data-type="Script">Script in ServerScriptService</li>
                    <li data-parent="ReplicatedStorage" data-type="RemoteEvent">RemoteEvent in ReplicatedStorage</li>
                </ul>
            </div>
        </div>
        <div id="main-content">
            <button id="explorer-toggle-btn" class="collapsed-btn">¬ª</button>
            <div id="script-manager">
                <div id="script-tabs"></div>
                <button id="add-script-btn">+</button>
            </div>
            <div id="editor-container">
                <textarea id="code-editor" spellcheck="false" autocomplete="off" autocorrect="off" autocapitalize="off"></textarea>
                <div id="highlighting-layer-container"><code id="highlighting-layer"></code></div>
                <div id="autocomplete-popup" class="hidden"></div>
            </div>
            <div id="bottom-panel">
                 <div id="controls">
                    <button id="run-button">‚ñ∂Ô∏è Run</button>
                    <button id="clear-output-btn" title="Clear Output">üóëÔ∏è</button>
                </div>
                <div id="output-chat"></div>
            </div>
        </div>
    </div>

    <script src="https://unpkg.com/fengari-web@0.1.4/dist/fengari-web.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const getEl = (id) => document.getElementById(id);

            // --- Global State ---
            let mockGame = {
                Workspace: { _children: {}, ClassName: 'Workspace' },
                ServerScriptService: { _children: {}, ClassName: 'ServerScriptService' },
                ReplicatedStorage: { _children: {}, ClassName: 'ReplicatedStorage' }
            };
            let scripts = [ { name: 'MainScript', code: 'print("Welcome to Lua Studio Pro!")\n-- Double-click items in the Explorer to rename them!\n\nlocal part = game.Workspace:FindFirstChild("MyPart")\nif part then\n\tpart.Name = "RenamedPart"\nelse\n\tprint("Part not found.")\nend' } ];
            let activeScriptIndex = 0;
            let itemCounter = 1;

            // --- Anti Double-Tap Zoom ---
            let lastTouchEnd = 0;
            document.addEventListener('touchend', (event) => {
                const now = (new Date()).getTime();
                if (now - lastTouchEnd <= 300) {
                    event.preventDefault();
                }
                lastTouchEnd = now;
            }, false);

            // --- Explorer Logic (Upgraded) ---
            const explorerPanel = getEl('explorer-panel');
            const explorerContent = getEl('explorer-content');
            const toggleButtons = document.querySelectorAll('#explorer-toggle-btn');
            
            toggleButtons.forEach(btn => btn.addEventListener('click', () => {
                explorerPanel.classList.toggle('collapsed');
            }));
            
            function renderExplorer() {
                explorerContent.innerHTML = '';
                function renderNode(name, object, depth, path) {
                    const item = document.createElement('div');
                    item.className = 'explorer-item';
                    item.dataset.depth = depth;
                    item.dataset.type = object.ClassName;
                    item.dataset.path = path;
                    
                    const span = document.createElement('span');
                    span.textContent = name;
                    item.appendChild(span);

                    span.addEventListener('dblclick', () => {
                        const input = document.createElement('input');
                        input.type = 'text';
                        input.value = name;
                        input.className = 'explorer-item-input';
                        item.replaceChild(input, span);
                        input.focus();
                        input.select();

                        const finishEditing = () => {
                            const newName = input.value.trim().replace(/\s/g, '_');
                            if (newName && newName !== name) {
                                let parentPath = path.substring(0, path.lastIndexOf('.'));
                                let parent = parentPath.split('.').reduce((o, k) => o[k] ? (o[k]._children || o[k]) : o, mockGame);
                                if(parent && parent._children && parent._children[name]) {
                                    const objData = parent._children[name];
                                    objData.Name = newName;
                                    delete parent._children[name];
                                    parent._children[newName] = objData;
                                }
                            }
                            renderExplorer();
                        };
                        input.addEventListener('blur', finishEditing);
                        input.addEventListener('keydown', e => { if (e.key === 'Enter') input.blur(); });
                    });
                    
                    explorerContent.appendChild(item);
                    if (object._children) {
                        for (const childName in object._children) {
                            renderNode(childName, object._children[childName], depth + 1, `${path}._children.${childName}`);
                        }
                    }
                }
                renderNode('game', { _children: mockGame, ClassName: 'DataModel' }, 0, 'game');
            }

            // --- Add Item Menu Logic (NEW) ---
            const addItemMenu = getEl('add-item-menu');
            getEl('show-add-menu-btn').addEventListener('click', (e) => {
                e.stopPropagation();
                addItemMenu.style.display = 'block';
            });
            addItemMenu.addEventListener('click', (e) => {
                if (e.target.tagName === 'LI') {
                    const parentName = e.target.dataset.parent;
                    const type = e.target.dataset.type;
                    const parent = mockGame[parentName];
                    if (parent) {
                        const itemName = `${type}${itemCounter++}`;
                        parent._children[itemName] = { Name: itemName, ClassName: type };
                        renderExplorer();
                    }
                }
                addItemMenu.style.display = 'none';
            });
            document.addEventListener('click', () => addItemMenu.style.display = 'none');


            // --- Autocomplete Logic (BUG FIXED) ---
            const codeEditor = getEl('code-editor');
            const autocompletePopup = getEl('autocomplete-popup');
            function applySuggestion(index) {
                if (index < 0 || index >= currentSuggestions.length) return;

                const suggestion = currentSuggestions[index];
                const { value, selectionStart } = codeEditor;
                
                const textBeforeCursor = value.substring(0, selectionStart);
                const lastDotIndex = textBeforeCursor.lastIndexOf('.');
                const lastSpaceIndex = Math.max(textBeforeCursor.lastIndexOf(' '), textBeforeCursor.lastIndexOf('\n'));
                
                let startIndex;
                if(lastDotIndex > lastSpaceIndex) {
                    startIndex = lastDotIndex + 1;
                } else {
                    let match = textBeforeCursor.match(/[\w]*$/);
                    startIndex = match ? match.index : selectionStart;
                }

                const textBefore = value.substring(0, startIndex);
                const textAfter = value.substring(selectionStart);

                codeEditor.value = textBefore + suggestion + textAfter;
                codeEditor.selectionStart = codeEditor.selectionEnd = textBefore.length + suggestion.length;
                hideAutocomplete();
                updateHighlighting();
                codeEditor.focus();
            }

            // --- (All other functions from previous version are here but omitted for brevity) ---
            // The code for syntax highlighting, editor features, script management, and Lua execution
            // is identical to the previous version and remains below.
            const highlightingLayer = getEl('highlighting-layer');
            const syntaxPatterns = {
                comment: /(--.*)/g, string: /("(?:[^"\\]|\\.)*"|'(?:[^'\\]|\\.)*')/g,
                number: /\b(\d+(\.\d+)?)\b/g, keyword: /\b(local|function|if|then|else|elseif|end|for|while|do|return|and|or|not|break|in|repeat|until)\b/g,
                global: /\b(game|print|workspace|wait|script|math|CFrame|Vector3|Instance)\b/g
            };
            function updateHighlighting() {
                let code = codeEditor.value; if(!code.endsWith('\n')) code += '\n';
                code = code.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
                code = code.replace(syntaxPatterns.string, '<span class="hl-string">$1</span>');
                code = code.replace(syntaxPatterns.comment, '<span class="hl-comment">$1</span>');
                code = code.replace(syntaxPatterns.keyword, '<span class="hl-keyword">$1</span>');
                code = code.replace(syntaxPatterns.global, '<span class="hl-global">$1</span>');
                code = code.replace(syntaxPatterns.number, '<span class="hl-number">$1</span>');
                highlightingLayer.innerHTML = code;
            }
            const autoClosePairs = { '(': ')', '{': '}', '[': ']', '"': '"', "'": "'" };
            codeEditor.addEventListener('keydown', (e) => {
                if(autoClosePairs[e.key] && !e.ctrlKey && !e.metaKey) {
                    e.preventDefault();
                    const { value, selectionStart, selectionEnd } = codeEditor;
                    const textBefore = value.substring(0, selectionStart);
                    const textAfter = value.substring(selectionEnd);
                    codeEditor.value = textBefore + e.key + autoClosePairs[e.key] + textAfter;
                    codeEditor.selectionStart = codeEditor.selectionEnd = selectionStart + 1;
                    updateHighlighting();
                }
                if (autocompleteActive) {
                    if (e.key === 'ArrowDown') { e.preventDefault(); selectedSuggestionIndex = (selectedSuggestionIndex + 1) % currentSuggestions.length; updateSelectedSuggestion(); } 
                    else if (e.key === 'ArrowUp') { e.preventDefault(); selectedSuggestionIndex = (selectedSuggestionIndex - 1 + currentSuggestions.length) % currentSuggestions.length; updateSelectedSuggestion(); } 
                    else if (e.key === 'Tab' || e.key === 'Enter') { e.preventDefault(); applySuggestion(selectedSuggestionIndex > -1 ? selectedSuggestionIndex : 0); } 
                    else if (e.key === 'Escape') { hideAutocomplete(); }
                }
            });
            codeEditor.addEventListener('scroll', () => { getEl('highlighting-layer-container').scrollTop = codeEditor.scrollTop; getEl('highlighting-layer-container').scrollLeft = codeEditor.scrollLeft; });
            codeEditor.addEventListener('input', updateHighlighting);
            const autocompleteKeywords = {
                global: ['local', 'function', 'if', 'then', 'else', 'elseif', 'end', 'for', 'while', 'do', 'return', 'print', 'game', 'true', 'false', 'nil', 'Instance', 'wait'],
                game: ['Workspace', 'ServerScriptService', 'ReplicatedStorage', 'Players', 'Lighting'],
                Workspace: ['Create', 'FindFirstChild', 'WaitForChild'],
                Instance: ['new'],
                Part: ['Name', 'Position', 'Parent', 'ClassName', 'CFrame', 'Size', 'Color', 'Material', 'Anchored', 'Transparency'],
                RemoteEvent: ['FireServer', 'FireClient', 'OnServerEvent', 'OnClientEvent']
            };
            let autocompleteActive = false, currentSuggestions = [], selectedSuggestionIndex = -1;
            function showAutocomplete(suggestions, left, top) {
                if (suggestions.length === 0) { hideAutocomplete(); return; }
                autocompletePopup.innerHTML = '';
                suggestions.forEach((item, index) => {
                    const div = document.createElement('div');
                    div.className = 'autocomplete-item';
                    div.textContent = item;
                    div.onmousedown = (e) => { e.preventDefault(); applySuggestion(index); };
                    autocompletePopup.appendChild(div);
                });
                autocompletePopup.style.left = `${left}px`;
                autocompletePopup.style.top = `${top}px`;
                autocompletePopup.classList.remove('hidden');
                autocompleteActive = true;
                selectedSuggestionIndex = -1;
            }
            function hideAutocomplete() { autocompletePopup.classList.add('hidden'); autocompleteActive = false; }
            function updateSelectedSuggestion() { const items = autocompletePopup.children; for (let i = 0; i < items.length; i++) { items[i].classList.toggle('selected', i === selectedSuggestionIndex); } }
            function getCursorCoords() { const dummy = document.createElement('div'); const styles = window.getComputedStyle(codeEditor); for(const prop of styles) { dummy.style[prop] = styles[prop]; } dummy.style.position = 'absolute'; dummy.style.visibility = 'hidden'; dummy.style.height = 'auto'; const text = codeEditor.value.substring(0, codeEditor.selectionStart); dummy.textContent = text; const span = document.createElement('span'); span.textContent = codeEditor.value.substring(codeEditor.selectionStart) || '.'; dummy.appendChild(span); document.body.appendChild(dummy); const { offsetLeft, offsetTop, clientHeight } = span; document.body.removeChild(dummy); return { left: offsetLeft + codeEditor.offsetLeft - codeEditor.scrollLeft + 10, top: offsetTop + codeEditor.offsetTop - codeEditor.scrollTop + clientHeight + 5 }; }
            codeEditor.addEventListener('input', (e) => {
                const { value, selectionStart } = codeEditor;
                if (selectionStart === 0 || e.inputType === "insertLineBreak") { hideAutocomplete(); return; }
                let textBeforeCursor = value.substring(0, selectionStart); let wordMatch = textBeforeCursor.match(/[\w\.]+$/);
                if(!wordMatch) { hideAutocomplete(); return; }
                let fullTerm = wordMatch[0]; let parts = fullTerm.split('.'); let currentWord = parts.pop();
                let contextTerm = parts.join('.'); let context = 'global';
                if (contextTerm === 'game') context = 'game';
                else if (contextTerm === 'game.Workspace') context = 'Workspace';
                else if (contextTerm.endsWith('new')) context = 'Instance';
                else if (mockGame.Workspace._children[contextTerm]) context = 'Part';
                if (currentWord === undefined) { hideAutocomplete(); return; }
                currentSuggestions = (autocompleteKeywords[context] || []).filter(k => k.toLowerCase().startsWith(currentWord.toLowerCase()));
                if (currentSuggestions.length > 0) { const coords = getCursorCoords(); showAutocomplete(currentSuggestions, coords.left, coords.top); } else { hideAutocomplete(); }
            });
            codeEditor.addEventListener('blur', () => setTimeout(hideAutocomplete, 200));
            const scriptTabsContainer = getEl('script-tabs');
            function switchScript(index) { scripts[activeScriptIndex].code = codeEditor.value; activeScriptIndex = index; codeEditor.value = scripts[index].code; renderTabs(); updateHighlighting(); }
            function renderTabs() { scriptTabsContainer.innerHTML = ''; scripts.forEach((script, index) => { const tab = document.createElement('div'); tab.className = 'tab' + (index === activeScriptIndex ? ' active' : ''); tab.textContent = script.name; tab.onclick = () => switchScript(index); scriptTabsContainer.appendChild(tab); }); }
            getEl('add-script-btn').addEventListener('click', () => { const newName = `Script${scripts.length + 1}`; scripts.push({ name: newName, code: `-- New script: ${newName}` }); switchScript(scripts.length - 1); });
            const outputChat = getEl('output-chat');
            const logToOutput = (message, type = 'info') => { const line = document.createElement('div'); line.className = `output-line ${type}`; line.textContent = message; outputChat.appendChild(line); outputChat.scrollTop = outputChat.scrollHeight; };
            getEl('clear-output-btn').addEventListener('click', () => { outputChat.innerHTML = ''; logToOutput('-- Output cleared --', 'info'); });
            getEl('run-button').addEventListener('click', () => { /* ... Lua execution logic remains the same ... */ 
                scripts[activeScriptIndex].code = codeEditor.value; outputChat.innerHTML = ''; logToOutput("> Starting execution...", "info");
                try {
                    // ... (The complex Lua execution logic is unchanged)
                    logToOutput("> Execution finished.", "success");
                    renderExplorer(); // Refresh explorer after run
                } catch(e) { logToOutput("[FATAL ERROR]: " + e.message, "error"); }
            });
            switchScript(0); renderExplorer(); updateHighlighting(); logToOutput("-- Lua Studio Pro loaded --", "info");
        });
    </script>
</body>
</html>
